"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.globModels = exports.DataSourceManager = void 0;
/**
 * 数据源管理器实现
 */
const extend_1 = require("../util/extend");
const error_1 = require("../error");
const glob_1 = require("@midwayjs/glob");
const path_1 = require("path");
const types_1 = require("../util/types");
const constants_1 = require("../constants");
class DataSourceManager {
    constructor() {
        this.dataSource = new Map();
        this.options = {};
        this.modelMapping = new WeakMap();
    }
    async initDataSource(options, appDir) {
        this.options = options;
        if (!options.dataSource) {
            throw new error_1.MidwayParameterError('[DataSourceManager] must set options.dataSource.');
        }
        for (const dataSourceName in options.dataSource) {
            const dataSourceOptions = options.dataSource[dataSourceName];
            if (dataSourceOptions['entities']) {
                const entities = new Set();
                // loop entities and glob files to model
                for (const entity of dataSourceOptions['entities']) {
                    if (typeof entity === 'string') {
                        // string will be glob file
                        const models = globModels(entity, appDir);
                        for (const model of models) {
                            entities.add(model);
                            this.modelMapping.set(model, dataSourceName);
                        }
                    }
                    else {
                        // model will be add to array
                        entities.add(entity);
                        this.modelMapping.set(entity, dataSourceName);
                    }
                }
                dataSourceOptions['entities'] = Array.from(entities);
            }
            // create data source
            const opts = {
                cacheInstance: options.cacheInstance,
                validateConnection: options.validateConnection,
            };
            await this.createInstance(dataSourceOptions, dataSourceName, opts);
        }
    }
    /**
     * get a data source instance
     * @param dataSourceName
     */
    getDataSource(dataSourceName) {
        return this.dataSource.get(dataSourceName);
    }
    /**
     * check data source has exists
     * @param dataSourceName
     */
    hasDataSource(dataSourceName) {
        return this.dataSource.has(dataSourceName);
    }
    getDataSourceNames() {
        return Array.from(this.dataSource.keys());
    }
    /**
     * check the data source is connected
     * @param dataSourceName
     */
    async isConnected(dataSourceName) {
        const inst = this.getDataSource(dataSourceName);
        return inst ? this.checkConnected(inst) : false;
    }
    async createInstance(config, clientName, options) {
        const cache = options && typeof options.cacheInstance === 'boolean'
            ? options.cacheInstance
            : true;
        const validateConnection = (options && options.validateConnection) || false;
        // options.clients[id] will be merged with options.default
        const configNow = (0, extend_1.extend)(true, {}, this.options['default'], config);
        const client = await this.createDataSource(configNow, clientName);
        if (cache && clientName && client) {
            this.dataSource.set(clientName, client);
        }
        if (validateConnection) {
            if (!client) {
                throw new error_1.MidwayCommonError(`[DataSourceManager] ${clientName} initialization failed.`);
            }
            const connected = await this.checkConnected(client);
            if (!connected) {
                throw new error_1.MidwayCommonError(`[DataSourceManager] ${clientName} is not connected.`);
            }
        }
        return client;
    }
    /**
     * get data source name by model or repository
     * @param modelOrRepository
     */
    getDataSourceNameByModel(modelOrRepository) {
        return this.modelMapping.get(modelOrRepository);
    }
    async stop() {
        const arr = Array.from(this.dataSource.values());
        await Promise.all(arr.map(dbh => {
            return this.destroyDataSource(dbh);
        }));
        this.dataSource.clear();
    }
    getDefaultDataSourceName() {
        if (this.innerDefaultDataSourceName === undefined) {
            if (this.options['defaultDataSourceName']) {
                this.innerDefaultDataSourceName = this.options['defaultDataSourceName'];
            }
            else if (this.dataSource.size === 1) {
                // Set the default source name when there is only one data source
                this.innerDefaultDataSourceName = Array.from(this.dataSource.keys())[0];
            }
            else {
                // Set empty string for cache
                this.innerDefaultDataSourceName = '';
            }
        }
        return this.innerDefaultDataSourceName;
    }
}
exports.DataSourceManager = DataSourceManager;
function globModels(globString, appDir) {
    let cwd;
    let pattern;
    if (globString.endsWith('**')) {
        // 去掉尾部的 **，因为 glob 会自动添加
        globString = globString.slice(0, -2);
    }
    if (/\*/.test(globString)) {
        cwd = appDir;
        pattern = [...constants_1.DEFAULT_PATTERN.map(p => (0, path_1.join)(globString, p))];
    }
    else {
        pattern = [...constants_1.DEFAULT_PATTERN];
        cwd = (0, path_1.join)(appDir, globString);
    }
    const models = [];
    // string will be glob file
    const files = (0, glob_1.run)(pattern, {
        cwd,
        ignore: constants_1.IGNORE_PATTERN,
    });
    for (const file of files) {
        const exports = require(file);
        if (types_1.Types.isClass(exports)) {
            models.push(exports);
        }
        else {
            for (const m in exports) {
                const module = exports[m];
                if (types_1.Types.isClass(module)) {
                    models.push(module);
                }
            }
        }
    }
    return models;
}
exports.globModels = globModels;
//# sourceMappingURL=dataSourceManager.js.map